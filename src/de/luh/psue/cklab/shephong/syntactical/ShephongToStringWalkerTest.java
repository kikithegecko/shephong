package de.luh.psue.cklab.shephong.syntactical;

import de.luh.psue.cklab.shephong.backend.ToStringWalker;
import static de.luh.psue.compiler.syntactical.Assert.*;
import junit.framework.TestCase;
import de.luh.psue.cklab.shephong.backend.GenerateStdLib;
import de.luh.psue.cklab.shephong.lexical.ShephongScannerTest;
import de.luh.psue.compiler.error.CompilerException;
import de.luh.psue.compiler.error.Reason;

import org.junit.Test;

/**
 * JUnit tests for the shephong parser.
 * 
 * @author shephongkrewe (none, autogenerated)
 *
 */
public class ShephongToStringWalkerTest extends TestCase {
	/**
	 * Call assertParsable from here, discarding the given argument
	 * and change it to a ToStringWalker instance.
	 *
	 * This whole file is automatically generated by a perl-script.
	 */
	@SuppressWarnings("unchecked")
	public void assertParsableWrapper (Class parserClass, String input, String expectedResult) throws CompilerException {
		assertParsable (parserClass, input, new ToStringWalker ());
	}

	private static String stdLib = GenerateStdLib.getStdLibString();
	/**
	 * Simple tests for the beginning
	 * 
	 * @throws CompilerException in case of wrong parsing.
	 */
	@Test
	public void testSimple() throws CompilerException{
		assertParsableWrapper(ShephongParser.class, "()", stdLib);
		assertParsableWrapper(ShephongParser.class, "", stdLib);
		assertParsableWrapper(ShephongParser.class, "(2 3)", stdLib + "3(2)\n");
		assertParsableWrapper(ShephongParser.class, "(ds 5 +)", stdLib + "+(list(5, ds))\n");
		assertParsableWrapper(ShephongParser.class, "(['b 4 +] f :)", stdLib + "(f = +[list(4, b)])\n");
		assertParsableWrapper(ShephongParser.class, "(2 3 b ?)", stdLib + "?(list(b, 3, 2))\n");
		assertParsableWrapper(ShephongParser.class, "(3 >)", stdLib + ">(3)\n");
		assertParsableWrapper(ShephongParser.class, "((($ ^) baz :) foo :)", stdLib + "(foo = (baz = ^($)))\n");
	}
	
	/**
	 * Some tests for the list syntax.
	 * 
	 * @throws CompilerException in case of wrong parsing.
	 */
	@Test
	public void testLists() throws CompilerException{
		assertParsableWrapper(ShephongParser.class, "(1 2 3 ~)", stdLib + "list(3, 2, 1)\n");
		assertParsableWrapper(ShephongParser.class, "[a b c ~]", stdLib + "list[c, b, a]\n");
		assertParsableWrapper(ShephongParser.class, "(a (b c ~) 3 ~)", stdLib + "list(3, list(c, b), a)\n");
		assertParsableWrapper(ShephongParser.class, "(('s h u ~) [8 4 +] 6 ~)", stdLib + "list(6, +[list(4, 8)], list(u, h, s))\n");
		assertParsableWrapper(ShephongParser.class, "(#1 2 #+) (1 #2 +)", stdLib + "#+(list(2, #1))\n+(list(#2, 1))\n");
	}
	
	/**
	 * Tests for the comment syntax. I know, this was already tested 
	 * in {@link ShephongScannerTest} but we want to make assurance
	 * double sure!
	 * 
	 * @throws CompilerException in case of wrong parsing.
	 */
	@Test
	public void testComments() throws CompilerException{
		assertParsableWrapper(ShephongParser.class, "{ comment! }", stdLib);
		assertParsableWrapper(ShephongParser.class, "{ (b a :) }", stdLib);
		assertParsableWrapper(ShephongParser.class, "(3) {<-three, four ->} (3 4 :)", stdLib + "3()\n(4 = 3)\n");
		assertParsableWrapper(ShephongParser.class, "{ \"}\" }", stdLib);
		assertParsableWrapper(ShephongParser.class, "{ foo { bar } baz }", stdLib);
	}
	
	/**
	 * Tests for the string syntax. Same as with {@link ShephongParserTest#commentTests()}:
	 * double assurance!
	 * 
	 * @throws CompilerException in case of wrong parsing.
	 */
	@Test
	public void testStrings() throws CompilerException{
		assertParsableWrapper(ShephongParser.class, "(123 \"foo\" ~)", stdLib + "list(list(o, o, f), 3(2(1(#0))))\n");
		assertParsableWrapper(ShephongParser.class, "(asd \")\" f)", stdLib + "f(list(list()), asd))\n");
		assertParsableWrapper(ShephongParser.class, "{ comment w \"} string\" ?}", stdLib);
	}
	
	/**
	 * Tests for more complex statements including nested statements
	 * and various combinations of dynamic statements, static statements,
	 * comments and strings.
	 * 
	 * @throws CompilerException in case of wrong parsing.
	 */
	@Test
	public void testComplexs() throws CompilerException{
		assertParsableWrapper(ShephongParser.class, 
				"[(4 7 8 ~) {<-list} ($2 $1 (0 2 =) ?) (\"foo!\" \"bar\" =) ?]",
				stdLib + "?[list(=(list(list(r, a, b), list(!, o, o, f))), ?(list(=(list(2, 0)), $1, $2)), list(8, 7, 4))]\n");
		assertParsableWrapper(ShephongParser.class,  
				"((((($1 2 -) (($1 1 -) fib) +) {else} 1 {then} (1 $1 =) {Bedingung} ?) {if, else-Teil vom ersten if} 0 {then} (0 $1 =) {Bedingung} ?) {if} fib :)",
				stdLib + "(fib = ?(list(=(list($1, 0)), 0, ?(list(=(list($1, 1)), 1, +(list(fib(-(list(1, $1))), -(list(2, $1)))))))))\n");
		assertParsableWrapper(ShephongParser.class, 
				"((((($ _) sum) ($^) +) 0 (($^) *crp* =) ?) sum :)", 
				stdLib + "(sum = ?(list(=(list(*crp*, ^($))), 0, +(list(^($), sum(_($)))))))\n");
		assertParsableWrapper(ShephongParser.class,  
				"([( \"abc\" (($^) 1 -) 2 /) (17 #3 *) ~] abc :)", 
				stdLib + "(abc = list[*(list(#3, 7(1(#0)))), /(list(2, -(list(1, ^($))), list(c, b, a)))])\n");
		assertParsableWrapper(ShephongParser.class,  
				"(fs 'a) [z (1 2 3 ~)] {crazy! \":}\"} (($_) a :)", 
				stdLib + "list(3, 2, 1)[z]\n" +
				"(a = _($))\n");
	}

	@Test
	public void testIncludes () throws CompilerException {
		assertParsableWrapper (ShephongParser.class,
				"((4 foo) bar :) (;include ESSEN;) [;include TRINKEN ; ]", 
				"modules used by this program:\n" +
				"module(ESSEN), module(TRINKEN)\n" +
				stdLib +
				"(bar = foo(4))\n" +
				"module(ESSEN)\n" +
				"module(TRINKEN)\n");
		assertParsableWrapper (ShephongParser.class,
				"((4 (; include 1   ;) )[ ;include include ;] )", stdLib);
	}
	
	@Test
	public void testEvals() throws CompilerException {
		assertParsableWrapper(ShephongParser.class,
				"((17 fak) `)",
				stdLib + "`(fak(7(1(#0))))\n");
	}

	@Test
	public void testFailures() throws CompilerException{
		// TODO uncomment in case of further implemenation of the rest...
//		assertNotParsable(ShephongParser.class, "\"string\"", null);
		assertNotParsable(ShephongParser.class, "(a) b)", 4, Reason.Syntactical);
		assertNotParsable(ShephongParser.class, "(ab ()", 6, Reason.Syntactical);
	}
}
